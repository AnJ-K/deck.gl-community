"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[549],{2777:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>c,frontMatter:()=>s,metadata:()=>r,toc:()=>l});var o=n(4848),i=n(8453);const s={},a="Write your own custom layout",r={id:"modules/graph-layers/api-reference/layouts/custom-layout",title:"Write your own custom layout",description:"Here's the method you will likely to implement when creating your own custom layout:",source:"@site/../docs/modules/graph-layers/api-reference/layouts/custom-layout.md",sourceDirName:"modules/graph-layers/api-reference/layouts",slug:"/modules/graph-layers/api-reference/layouts/custom-layout",permalink:"/deck.gl-community/docs/modules/graph-layers/api-reference/layouts/custom-layout",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/deck.gl-community/tree/master/website/../docs/modules/graph-layers/api-reference/layouts/custom-layout.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"D3 Force Layout",permalink:"/deck.gl-community/docs/modules/graph-layers/api-reference/layouts/d3-layout"},next:{title:"Experimental Layouts",permalink:"/deck.gl-community/docs/modules/graph-layers/api-reference/layouts/layout-gallery"}},d={},l=[{value:"Lifecycles",id:"lifecycles",level:3},{value:"constructor",id:"constructor",level:3},{value:"Update the graph data",id:"update-the-graph-data",level:3},{value:"Compute layout",id:"compute-layout",level:3},{value:"Update layout",id:"update-layout",level:3},{value:"Getters",id:"getters",level:3},{value:"Full source code",id:"full-source-code",level:3}];function h(e){const t={code:"code",h1:"h1",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"write-your-own-custom-layout",children:"Write your own custom layout"}),"\n",(0,o.jsx)(t.p,{children:"Here's the method you will likely to implement when creating your own custom layout:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"import {BaseLayout} from 'react-graph-layers';\n\nexport default class MyLayout extends BaseLayout {\n  // initialize the layout\n  constructor(options) {}\n  // first time to pass the graph data into this layout\n  initializeGraph(graph) {}\n  // update the existing graph\n  updateGraph(grpah) {}\n  // start the layout calculation\n  start() {}\n  // update the layout calculation\n  update() {}\n  // resume the layout calculation manually\n  resume() {}\n  // stop the layout calculation manually\n  stop() {}\n  // Access the position of the node in the layout\n  // If the position is not available (not calculated), returning nullish will hide the node.\n  getNodePosition(node) {}\n  // access the layout information of the edge\n  getEdgePosition(edge) {}\n  // Pin the node to a designated position, and the node won't move anymore\n  lockNodePosition(node, x, y) {}\n  // Unlock the node, the node will be able to move freely.\n  unlockNodePosition(node) {}\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["We will start with a ",(0,o.jsx)(t.code,{children:"RandomLayout"})," as an example, you can follow the steps one by one and find the source code at the bottom."]}),"\n",(0,o.jsx)(t.h3,{id:"lifecycles",children:"Lifecycles"}),"\n",(0,o.jsx)(t.p,{children:"For a graph layout, everything goes through a set of events. In each event, the layout will need to take the inputs and do the different computations. Lifecycle methods are various methods which are invoked at different phases of the lifecycle of a graph layout. If you are aware of these lifecycle events, it will enable you to control their entire flow and it will definitely help us to produce better results."}),"\n",(0,o.jsx)(t.p,{children:"A layout goes through the following phases:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["Mounting:\n",(0,o.jsx)(t.code,{children:"constructor"})," => ",(0,o.jsx)(t.code,{children:"initializeGraph"})," => ",(0,o.jsx)(t.code,{children:"start"})]}),"\n",(0,o.jsxs)(t.li,{children:["Updating:\n",(0,o.jsx)(t.code,{children:"updateGraph"})," => ",(0,o.jsx)(t.code,{children:"update"})]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"There are a few events that should be triggered when the layout changes:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"this._onLayoutStart()"}),"\nWhen the layout starts, ",(0,o.jsx)(t.code,{children:"onLayoutStart"})," should be triggered to notify GraphGL/User. Some users might also want to leverage this event hook to perform different interactions, ex: show a spinner on the UI to indicate a new layout is computing."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"this._onLayoutChange()"}),"\nEvery time when the layout changes, ",(0,o.jsx)(t.code,{children:"onLayoutChange"})," should be triggered to notify GraphGL to re-render and update the view. Then GraphGL will use ",(0,o.jsx)(t.code,{children:"getNodePosition"})," and ",(0,o.jsx)(t.code,{children:"getEdgePosition"})," to get the position information to render the graph. Some users might also want to leverage this event hook to perform different interactions, ex: show a spinner on the UI to indicate the layout is computing."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"this._onLayoutDone()"}),"\nWhen the layout is completed, 'onLayoutDone' should be triggered to notify GraphGL/User. Some users might also want to leverage this event hook to perform different interactions, ex: remove the spinner from the UI."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"If you want to implement the drag & drag interaction on nodes, you will have to implement:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"lockNodePosition"}),": pin the node at the designated position."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"unlockNodePosition"}),": free the node from the position."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"resume"}),": resume the layout calculation."]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"The sequence of the events is like:\nstartDragging => lockNodePosition => release => unlockNodePosition => resume"}),"\n",(0,o.jsx)(t.h3,{id:"constructor",children:"constructor"}),"\n",(0,o.jsx)(t.p,{children:"In the constructor, you can initialize some internal object you'll need for the layout state.\nThe most important part is to create a 'map' to keep the position of nodes."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"export default class RandomLayout extends BaseLayout {\n  static defaultOptions = {\n    viewportWidth: 1000,\n    viewportHeight: 1000\n  };\n\n  constructor(options) {\n    // init BaseLayout\n    super(options);\n    // give a name to this layout\n    this._name = 'RandomLayout';\n    // combine the default options with user input\n    this._options = {\n      ...this.defaultOptions,\n      ...options\n    };\n    // a map to persis the position of nodes.\n    this._nodePositionMap = {};\n  }\n}\n"})}),"\n",(0,o.jsx)(t.h3,{id:"update-the-graph-data",children:"Update the graph data"}),"\n",(0,o.jsxs)(t.p,{children:["GraphGL will call ",(0,o.jsx)(t.code,{children:"initializeGraph"})," to pass the graph data into the layout.\nIf the graph is the same one but part ofthe data is changed, GraphGL will call ",(0,o.jsx)(t.code,{children:"updateGraph"})," method to notify the layout."]}),"\n",(0,o.jsxs)(t.p,{children:["In this case, we can just simply update the ",(0,o.jsx)(t.code,{children:"this._nodePositionMap"})," by going through all nodes in the graph."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"  initializeGraph(graph) {\n    this.updateGraph(graph);\n  }\n\n  updateGraph(grpah) {\n    this._graph = graph;\n    this._nodePositionMap = graph.getNodes().reduce((res, node) => {\n      res[node.getId()] = this._nodePositionMap[node.getId()] || [0, 0];\n      return res;\n    }, {});\n  }\n"})}),"\n",(0,o.jsx)(t.h3,{id:"compute-layout",children:"Compute layout"}),"\n",(0,o.jsxs)(t.p,{children:["GraphGL will call ",(0,o.jsx)(t.code,{children:"start()"})," of the layout to kick start the layout calculation.\nBefore starting the calculation you should call ",(0,o.jsx)(t.code,{children:"this._onLayoutStart()"})," to notify that a new layout has been started\nIn this case, the computation is easy as assigning random position for each node only.\nOnce the layout is completed, you will need to call ",(0,o.jsx)(t.code,{children:"this._onLayoutChange()"})," to notify the render redraw.\nThen call ",(0,o.jsx)(t.code,{children:"this._onLayoutDone()"})," to notify the render that layout is completed."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"  start() {\n    const {viewportWidth, viewportHeight} = this._options;\n    this._onLayoutStart();\n    this._nodePositionMap = Object.keys(this._nodePositionMap).reduce((res, nodeId) => {\n      res[nodeId] = [Math.random() * viewportWidth, Math.random() * viewportHeight];\n      return res;\n    }, {});\n    this._onLayoutChange();\n    this._onLayoutDone();\n  }\n"})}),"\n",(0,o.jsx)(t.h3,{id:"update-layout",children:"Update layout"}),"\n",(0,o.jsxs)(t.p,{children:["GraphGL will call ",(0,o.jsx)(t.code,{children:"update()"})," of the layout to update the layout calculation when a full new layout is not required.\nMost commonly this will be when nodes or edges of the graph are updated.\nIn this case we will simply assign a random position for each node.\nOnce the layout is completed, you will need to call ",(0,o.jsx)(t.code,{children:"this._onLayoutChange()"})," to notify the render redraw.\nThen call ",(0,o.jsx)(t.code,{children:"this._onLayoutDone()"})," to notify the render that layout is completed."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"  update() {\n    const {viewportWidth, viewportHeight} = this._options;\n    this._nodePositionMap = Object.keys(this._nodePositionMap).reduce((res, nodeId) => {\n      res[nodeId] = [Math.random() * viewportWidth, Math.random() * viewportHeight];\n      return res;\n    }, {});\n    this._onLayoutChange();\n    this._onLayoutDone();\n  }\n"})}),"\n",(0,o.jsx)(t.h3,{id:"getters",children:"Getters"}),"\n",(0,o.jsxs)(t.p,{children:["GraphGL will keep retrieving the position of nodes and edges from the layout. You will need to provide two getters ",(0,o.jsx)(t.code,{children:"getNodePosition"})," and ",(0,o.jsx)(t.code,{children:"getEdgePosition"}),"."]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"getNodePosition: return the position of the node [x, y]. If the position is not available (not calculated), returning nullish will hide the node."}),"\n",(0,o.jsx)(t.li,{children:"getEdgePosition: return the rendering information of the edge, including:\n-- type: the type of the edge, it should be 'LINE', 'SPLINE_CURVE', or 'PATH'.\n-- sourcePosition: the position of source node.\n-- targetPosition: the position of target node.\n-- controlPoints: a set of control points for 'SPLINE_CURVE', or 'PATH' edge."}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"getNodePosition = (node) => this._nodePositionMap[node.getId()];\n\ngetEdgePosition = (edge) => {\n  const sourcePos = this._nodePositionMap[edge.getSourceNodeId()];\n  const targetPos = this._nodePositionMap[edge.getTargetNodeId()];\n  return {\n    type: EDGE_TYPE.LINE,\n    sourcePosition: sourcePos,\n    targetPosition: targetPos,\n    controlPoints: []\n  };\n};\n"})}),"\n",(0,o.jsx)(t.h3,{id:"full-source-code",children:"Full source code"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"import {BaseLayout} from 'react-graph-layers';\n\nexport default class RandomLayout extends BaseLayout {\n  constructor(options) {\n    super(options);\n    this._name = 'RandomLayout';\n    this._options = {\n      ...defaultOptions,\n      ...options\n    };\n    this._nodePositionMap = {};\n  }\n\n  // first time to pass the graph data into this layout\n  initializeGraph(graph) {\n    this.updateGraph(graph);\n  }\n  // update the existing graph\n  updateGraph(grpah) {\n    this._graph = graph;\n    this._nodePositionMap = graph.getNodes().reduce((res, node) => {\n      res[node.getId()] = this._nodePositionMap[node.getId()] || [0, 0];\n      return res;\n    }, {});\n  }\n\n  start() {\n    const {viewportWidth, viewportHeight} = this._options;\n    this._onLayoutStart();\n    this._nodePositionMap = Object.keys(this._nodePositionMap).reduce((res, nodeId) => {\n      res[nodeId] = [Math.random() * viewportWidth, Math.random() * viewportHeight];\n      return res;\n    }, {});\n    this._onLayoutChange();\n    this._onLayoutDone();\n  }\n\n  update() {\n    const {viewportWidth, viewportHeight} = this._options;\n    this._nodePositionMap = Object.keys(this._nodePositionMap).reduce((res, nodeId) => {\n      res[nodeId] = [Math.random() * viewportWidth, Math.random() * viewportHeight];\n      return res;\n    }, {});\n    this._onLayoutChange();\n    this._onLayoutDone();\n  }\n\n  getNodePosition = (node) => this._nodePositionMap[node.getId()];\n\n  getEdgePosition = (edge) => {\n    const sourcePos = this._nodePositionMap[edge.getSourceNodeId()];\n    const targetPos = this._nodePositionMap[edge.getTargetNodeId()];\n    return {\n      type: EDGE_TYPE.LINE,\n      sourcePosition: sourcePos,\n      targetPosition: targetPos,\n      controlPoints: []\n    };\n  };\n}\n"})})]})}function c(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var o=n(6540);const i={},s=o.createContext(i);function a(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);